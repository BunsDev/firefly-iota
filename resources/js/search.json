[[{"l":"Welcome","p":["Welcome to the Firefly handbook!"]}],[{"l":"Guides","p":["Welcome to the Firefly team's guides!"]}],[{"l":"Coding Conventions","p":["TODO"]}],[{"l":"Comments","p":["Every time you express yourself in code, you should pat yourself on the back. Every time you write a comment, you should grimace and feel the failure of your ability of expression.","In general it is preferable to avoid writing comments, especially if there is a way to cleanly express the logic with the code itself(aka self-documenting code). Otherwise, we adhere to the following rules about comments:","Do NOT write comments that are noisy or state the obvious","Do NOT write TODO comments","ℹ️ If you find yourself writing TODO comments, instead create a new task on GitHub or add to your existing task's requirements list.","Do NOT write embedded comments","Bad","Good","They should be preceded by a blank without a following a blank line"]}],[{"l":"Formatting"},{"l":"Brackets","p":["We adhere to the one true brace style(OTBS) for brackets. OTBS means that the opening brace for a code block follows its corresponding statement or declaration on the same line.","Bad","Good","The only circumstances where curly brackets may be omitted are when...","An anonymous callback or lambda function is being defined, e.g.","Bad(excessive)","Good(concise)","Handling a (simple) case inside of a switch statement, e.g."]},{"l":"Commas","p":["Unless the file in question is of JSON format, we should use trailing commas wherever possible in the code. In short trailing commas follow the last item in a larger array, despite not having a following item. The reason for this is to make code more editable when we need to move, add, or remove data from said array.","Bad","Good","⚠️ JSON does NOT support trailing commas; only ES5+ code."]},{"l":"Quotes","p":["We use single quotes throughout the codebase.","Bad","Good","We use double quotes only in the following places:","JSON metadata ( NOT supported)","Rust source code ( NOT syntactical)","HTML elements attributes (purely stylistic as single quotes are supported here)"]},{"l":"Semicolons","p":["We are choosing to NOT use semicolons anywhere in the code (unless it is SCSS/CSS code as it is hard-requirement of the syntax)."]},{"l":"Spacing","p":["Spacings are another consideration to make when writing clean code.","They are used in the following places:","After a comment","Bad","Good","Before and after parentheses for if statements","Before and after parentheses for for loops","Before and after parentheses for switch statements","Inside import statements","Inside object definitions","⚠️ Do NOT use tabs for indentation; use spaces instead."]}],[{"l":"Imports"},{"l":"Path Aliases","p":["Path aliases are useful for avoiding long relative import paths and improving the readability of our import statements.","We use the following aliases throughout the entire application:","@core","Contents: code components used in core functionality of the app, e.g. routing, internationalization (i18n), notifications","Location: packages/shared/lib/core/","@common","Contents: code components used commonly throughout the application, e.g. functionality for sending transactions, stores for a profile","Location: packages/shared/lib/common/","@components","Contents: re-usable Svelte UI components used inside of the route components, e.g. buttons, text, popups","Location: packages/shared/components/","Bad","Good"]},{"l":"Order","p":["With clean and easy to read import statements you can quickly see the dependencies of the current code. Make sure you apply following good practices for import statements:","There are no unused imports","Each import group must be separated by a blank line","An import group's import statements must be sorted alphabetically according to their path alias","An import statement's individual imports must be sorted alphabetically according to their variable name","All import groups must adhere to this order:","Svelte library modules (e.g. import { get } from 'svelte/store')","Third-party imports (e.g. import { Converter } from '@iota/client')","Svelte UI components (e.g. import { Button, Text } from '@components')","TypeScript core modules (e.g. import { setRoute } from @core/router)","TypeScript common modules (e.g. import { isStrongholdLocked } from '@common/stronghold/stores')","ℹ️ To help enforce this import strategy, we should look at something like eslint-plugin-import.","Bad","Good"]}],[{"l":"Internationalization","p":["Internationalization refers to designing a product in such a way that it can easily be localized (i.e. localization) into a target language. We currently use the svelte-i18n library to handle this functionality.","⚠️ Localization should be used only when dealing with user-facing text; if the user is not intended to see a message or error, then it does NOT need to be localized."]},{"l":"Usage","p":["It is quite easy to use svelte-i18n once it has been configured and initialized. We simply import the localize(...) function, which allows us to create any localization as long as there is an entry for it in a corresponding {language}.json file.","If the provided path for the locale data does NOT exist, the text will default to English. In the case that the English also does NOT exist, an undefined value will be returned."]},{"l":"International Components for Unicode","p":["As is the norm for internationalization functionality, we adhere to the widely used ICU(International Components for Unicode) message format for creating better adapted localizations. With it, we can...","Create translations with no dynamic data","Create translations with simple dynamic data","Create translations with dynamic amounts","Create translations with multiple conditions","⚠️ Punctuation may or may NOT be used in a locale entry; if relevant, see similar texts to determine if you should use punctuation (e.g. setting description text does NOT use punctuation).","ℹ️ Although these four usages cover our needs well, there are a few more available functionalities specifically surrounding numbers, dates, and times (see here)."]}],[{"l":"Naming","p":["Naming is perhaps one of the most important skills for writing clean code. Upon first read, a name should indicate to developers the following things:","Why the code exists?","What is the purpose of the code?","How is the code used?"]},{"l":"General","p":["The following are some general rules about code naming that we follow:","They must be meaningful","Bad","Good","They must be pronounceable","They must NOT be mental mappings","They must NOT add unneeded context"]},{"l":"Acronyms","p":["When a variable name contains an acronym, the first letter must be uppercase and the rest lowercase. This convention creates more readable names particularly in the circumstances where another word follows the acronym.","Bad","Good"]},{"l":"Booleans","p":["All objects, functions, stores, i.e. code components of boolean type must be prefixed with being verbs (e.g. \"is\", \"are\", \"has\", \"will\", \"can\", \"should\", \"must\")","Bad","Good","ℹ️ This also pertains to any functions that are of boolean type; isStrongholdLocked() is more self-documenting than strongholdLocked().","All booleans must use positive names"]},{"l":"Constants","p":["All constants must be in SCREAMING_SNAKE_CASE","Bad","Good"]},{"l":"Enumerations","p":["All enum and enum variant names must be in PascalCase","Bad","Good","All enum names must be singular"]},{"l":"Functions","p":["All function names must be in camelCase","Bad","Good"]},{"l":"Interfaces","p":["All interface names must be in PascalCase preceded with an I","Bad","Good"]},{"l":"Types","p":["All type names must be in PascalCase","Bad","Good"]}],[{"l":"Svelte Components"},{"l":"Organization","p":["The organization of a Svelte component must start with the script, followed by the markup and the style.","Bad","Good"]},{"l":"Reactivity","p":["At the heart of Svelte is a powerful system of reactivity for keeping the DOM in sync with the application state — for example, in response to an event. This section describes our approach to throughout the codebase. Reactive stores (a language feature) assign a store value (app state) to a local variable, and thanks to Svelte reactivity all the markup and reactive dependencies are updated in Svelte Components.","It's not enforced, since regular typescript handles store variables differently. However, the following approach is preferred in Svelte components. Feel free to test the code on the Svelte Playground!","Preferred","The same code can be written without using Svelte language features. The following code does the same, albeit being a bit more verbose. This is how store interactions are written in pure typescript. It is accepted, but for Svelte components preference is given to the style described above.","Alternative"]},{"l":"Styling"},{"l":"Tailwind","p":["TODO"]},{"l":"style Tag","p":["TODO"]},{"l":"Prettier","p":["There is a bug in Prettier's Svelte Plugin that replaces nested style and script tags with base58 encoded strings of vanilla JS. Use nested strings in case nested style/script tags are required.","Bad","Good"]}],[{"l":"TypeScript Library"},{"l":"Organization","p":["Modules are the heart of our TypeScript library; they house the various types of code components we use, namely:","api- wallet-rs wrapper and bridge functions","constants- global, never-changing values","enums- enum definitions","interfaces- module API declarations","stores- Svelte store objects","tests- module unit tests","types- type definitions","various smaller business-logic files and API or bridge files","barrel files","The following is a typical module structure:"]},{"l":"Barrels","p":["A barrel is an intermediary module that rolls up exports from other files and re-exports them. They are the index.(ts|js) files that live within modules.","The functions must be barrel-exported exported within the index.ts file.","Then they can be used within a UI component or another library file."]},{"l":"Constants","p":["Constants are never-changing values that can be used throughout the entire application (i.e. Svelte UI components and other library files). For a variable to be a constant, it must be evaluated at compile-time rather than runtime.","Bad","Good"]},{"l":"Enumerations","p":["Enumerations are objects that define one or more variants of a certain type.","Defining an enumeration","Handling different enum cases"]},{"l":"Functions","p":["Functions are callable objects that perform some type of operation; they are the building blocks of our application. As such, we have different ways that we use them.","There are some general considerations we should all keep in mind when writing functions:","They should be small and contained. When functions have lots of code that is doing many different things, it is hard to navigate and reason about, ultimately making it hard to debug problems or add new features. It is most likely best that the function be refactored into multiple smaller functions within a larger one.","They should contain little-to-no side-effects. These also make code difficult to debug, extend or test, simply because you cannot be sure that a function did only what it said it was going to do. We should apply a more functional-style of programming, the idea being mainly that functions simply (and deterministically) return outputs as a result of some input (i.e. pure functions)."]},{"l":"Regular Functions","p":["These are the most common type of function that we write. They are used in Svelte components, library files, and other places in our applcation.","They have the following rules:","All regular functions must be declared with the function keyword","All regular function signatures must be explicitly typed","Bad","Good"]},{"l":"Anonymous Functions","p":["These are small, unnamed functions that we typically use as callbacks, lambdas, etc.","They have the following rules:","All anonymous functions should be in the ES6 arrow-style syntax; do NOT use the function keyword*","Any anonymous function may be explicitly typed (usually if a type is a non-primitive, e.g. NOT string, number, boolean, etc.)","* The exception to this is when you pass a regular function to a higher-order function.","Bad","Good"]},{"l":"Wrapper Functions","p":["These are the functions that internally access the api object, which contains the API methods for wallet.rs.","They have the following rules:","All wrapper functions must be declared with the function keyword","All wrapper functions must be explicitly typed","All wrapper functions must return a Promise-based type","All wrapper functions must allow for optional callbacks (e.g. onSuccess, onError)","All wrapper functions must be free of side-effects","Bad","Good","ℹ Responses are validated in the onMessage callback via the Validator class."]},{"l":"Interfaces","p":["Interfaces are objects that declare a collection of related functions.","For example, we can define an IStrongholdApi type that declares the API we will use to interact with Stronghold.","❌ Interfaces should NOT be used to define a data type; instead use the type keyword."]},{"l":"Tests","p":["Tests are files containing one or more unit tests for functions in its corresponding source code file. The tests within a module form a test suite. It is worth noting that if the filename is the-file.ts then its test should be named the-file.test.ts.","See the Testing guide for more info on how to run tests."]},{"l":"Writing","p":["Most of the test files should have a structure like this:"]},{"l":"Mocking","p":["Mocks are files that imitate objects or functionality for the sake of testing something. There may be different requirements per whatever it is that is being mocked or will be using the mock, so they may not necessarily all look the same.","To use a mock, simply import it at the beginning of a test file."]},{"l":"Types","p":["Types are definitions of how some piece of data should be shaped, what is inside of it, etc.","It is good practice to explicitly define types for data even if it is simply a number or string, particularly if it is something within our domain. The largest benefit is that if the type were to change at a later point it would be much easier to implement as we would only need to change the defintion rather than all the places where it's used."]}],[{"l":"Environment Setup"},{"l":"Base Setup","p":["The following must be installed on all platforms:","Node.js 12+ (NOTE: There may be issues with Node.js 15 on Windows)","Yarn","Rust"]},{"l":"MacOS","p":["Xcode Command Line Tools"]},{"l":"Windows","p":["It is highly recommended to use Chocolatey as a package manager for Windows. There are a few dependencies that Chocolatey handles smoothly, which otherwise are often troublesome to install and configure. Read installation steps here.","PowerShell in administrator mode is recommended for the following steps.","Install dependencies for wallet.rs:","NOTE: llvm can also be downloaded and installed with snapshot builds.","Install and configure dependencies for Windows:","NOTE: Alternatively, you can download Microsoft C++ Build Tools. You must check boxes for \"Node.js development\" and \"Desktop development with C++\" within the Visual Studio Installer (use the 2019 version).","Add environment variable definitions in ~/.bash_profile or ~/.bashrc:"]},{"l":"Linux","p":["Snapcraft( sudo snap install snapcraft --classic)","Multipass( sudo snap install multipass) or LXD( snap install lxd) are necessary for Snap compilation (to bypass this requirement and build on the host, set SNAP_DESTRUCTIVE_MODE=true)","build-essential","clang(on some older distros, you may need to add LLVM APT repos)","libsecret(Debian/Ubuntu: libsecret-1-dev, Red Hat: libsecret-devel, Arch Linux: libsecret)","libssl(Debian/Ubuntu: libssl-dev, Red Hat: openssl-devel, Arch Linux: openssl)","libusb(Debian/Ubuntu: libusb-1.0-0-dev)","libudev(Debian/Ubuntu: libudev-dev)","gnome-keyring, keepassxc, or another secrets manager that implements the freedesktop.org Secrets API"]},{"i":"desktop","l":"Desktop \uD83D\uDDA5️"},{"l":"Build","p":["Install yarn dependencies:","Build desktop app:"]},{"l":"Development"},{"l":"Production","p":["Change platform as necessary ( win, mac, and linux):","MacOS users must set an environment variable in order to skip notarization:","If Sentry bug reporting needs to be enabled for a local production build, you must modify the packages.json file within packages/desktop/:"]},{"l":"Firefly Snap","p":["To run the Firefly snap properly on Linux, you may need to run the following commands:"]},{"i":"mobile","l":"Mobile \uD83D\uDCF1"},{"l":"Dev Mode"},{"i":"web-extension","l":"Web Extension \uD83D\uDD0C","p":["WIP"]}],[{"l":"Desktop","p":["TODO"]}],[{"l":"Extension","p":["TODO"]}],[{"l":"Ledger","p":["TODO"]}],[{"l":"Mobile","p":["TODO"]}],[{"l":"Git","p":["TODO"]}],[{"l":"Branches","p":["Branch names must follow a certain structure, which is branch-prefix/branch-name. The branch-prefix corresponds to one of the conventional commit types defined above and the branch name is a concise but informative name representing your changes, e.g. feat/your-cool-feature and chore/new-doc. PR titles are based off of the branch name, so for the examples just used they should be\"feat: Your cool feature\" and \"chore: New doc\"."]}],[{"l":"Commits","p":["We use Conventional Commits, so that commit messages are clean and concise. They should follow a consistent structure, being written in present-tense and using the prefixes below:","chore: modifies documentation, cleaning dependencies, other housekeeping-like tasks","ci: creates or changes an existing continuous integration workflow (checkout ci.*.yml files in firefly/.github/workflows/)","feat: introduces a new feature or enhancement of an existing feature","fix: fixes or patches a bug in app functionality","refactor: improvements made to existing code","style: adjusts component styling or UI-only changes","test: changes made only to unit or integration tests","An example might be: feat: Add conversion function for IOTA to fiat currency","The granularity of the commits are ultimately up to you, however we prefer keeping the number of commits lower if possible. The commits are squashed in the end as a change-log / summary of the PR, so do not worry too much."]}],[{"l":"Pull Requests","p":["TODO"]}],[{"l":"Developer Tips","p":["TODO"]}],[{"l":"Testing","p":["TODO(everything besides writing tests since that is coding conventions)"]}],[{"l":"Standard Operating Procedures","p":["TODO"]}],[{"l":"Documentation","p":["TODO"]},{"l":"Purpose"},{"l":"Scope"},{"l":"Responsibilities"},{"l":"Processes"},{"l":"External Processes"}],[{"l":"Issues"},{"l":"Purpose","p":["This document details the standard operating procedure (SOP) for maintaining issues that have been raised on GitHub; allowing all team members to remain consistent when organising and maintaining the issues backlog."]},{"l":"Scope","p":["This standard operating procedure is only applicable to maintainers of this repository responsible for the issues backlog; and the issues backlog is that which is found on GitHub only."]},{"l":"Responsibilities","p":["All members of the core firefly team are responsible for managing issues. If an issue is assigned to you, then it is your responsibility. For those issues without an assignee, we aim to follow a rota to ensure that someone is always responsible for new issues created. You will find an up to date rota below."]},{"l":"Issue management rota","p":["01/11/2021","05/12/2021","06/12/2021","07/11/2021","08/11/2021","12/12/2021","13/12/2021","14/11/2021","15/11/2021","19/12/2021","21/11/2021","22/11/2021","28/11/2021","29/11/2021","Amadeo","Begoña","Charlie","Developer","Lead","Matt","Nicole","None","Umair","Week Commencing","Week Ending"]},{"l":"Processes","p":["Bug Management Process","Support Request Process"]},{"l":"External Processes","p":["Security Vulnerability Process"]},{"l":"Bug Management Process","p":["The bug management process is to be followed when an issue is raised on GitHub that has the label type:bug or an existing issue has been given the label type:bug."]},{"l":"High Level Overview","p":["Bug Triage Process - HLD","The above diagram details the high level overview of the bug management processes:","Asses whether the issue issue is a valid.","Triage the issue.","Prioritize and schedule the issue to be fixed.","Fix the issue.","When managing issues please make sure you assign yourself to the issue on GitHub."]},{"l":"Assessment Process","p":["Bug Triage Process - Assessment Process","The assessment process is usually followed as soon as an issue is labeled as type:bug, this is to ensure that we don't need to triage invalid issues. If you are on the Rota when this happens, you should assign yourself to the issue and then follow the above process as soon as possible."]},{"l":"Triage Process","p":["Bug Triage Process - Triage Process","Once an issue has been assessed, we can then triage the issue to decide if we should fix the issue or if we just want to acknowledge the issue because we aren't planning to fix it. This should be done as soon as possible, by following the above process."]},{"l":"Prioritise and Schedule Process","p":["Bug Triage - Prioritise Process","If an bug has been triaged and it is agreed that we should fix the issue, then we need to prioritise the fix and schedule this fix. Again this should be done as soon as possible after triaging, and can be done by following the above process."]},{"l":"Support Request Process","p":["TODO: Define and document support request process"]}],[{"l":"Releases"},{"l":"Changelog","p":["Version","Change","Author","Date","1.0","Initial SOP for regular release, milestone release and hotfix releases","@Nicole","21/02/2022"]},{"l":"Purpose","p":["This document details the standard operating procedure (SOP) for managing the releases of the Firefly Application, so that anyone one of the maintainers can correctly create a release."]},{"l":"Scope","p":["This SOP is only applicable to maintainers of this repository, that are responsible for the release process. Currently this SOP only covers Desktop releases for Linux, Mac and Windows."]},{"l":"Responsibilities","p":["Role","Person","Primary Release Manager","@Nicole","Secondary Release Manager","???"]},{"l":"Schedule","p":["Once a month on the last wednesday the regular release process will be initiated.","The milestone release process will happen for larger milestone based releases, or releases of new platforms.","Hotfixes will occur when there is an important fix that needs to be deployed on a currently released version, before the next regular rlease."]},{"l":"Processes","p":["Release Versioning","Regular Release Process","Milestone Release Process","Hotfix Release Process"]},{"l":"External References","p":["Guide: Branching Strategy","Guide: Pull Requests"]},{"l":"Release Versioning","p":["We aim to follow a release versioning convention as close to semantic versioning as possible.","Given a version number MAJOR.MINOR.PATCH, increment the:","MAJOR version when you make incompatible API changes,","MINOR version when you add functionality in a backwards compatible manner, and","PATCH version when you make backwards compatible bug fixes.","Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.","i.e. our versioning will look like: 1.3.4","Where we use the optional channel and build number for pre-releases. 1.3.4-alpha-1 1.3.4-beta-1","In tags and branches, the versioning will also be prefixed with the platform: desktop-1.4.0- branch or production release tag mobile-1.0.0-alpha-1- pre-release tag"]},{"l":"Regular Release Process","p":["The regular release process should be followed monthly according to the schedule defined in this SOP. This is to ensure we are providing consistent updates and bug fixes for all platforms.","As a prerequisite to the release process, both the branching strategy and PR management process are to be followed.","For the regular release process we will aim to follow the below sub processes:"]},{"i":"1-pr-freeze--release-branch","l":"1. PR freeze & release branch","p":["When the regular release process is initiated, the first step is to issue a PR freeze (on the develop branch) to all the maintainers. This will be a simple reminder to tell them that no more PRs will be merged into develop after a given time, until the release branch has been created.","This includes all PR regardless of specific target platform, as the code is closely linked for all platforms.","Usually the release branch will be created in a short time afterwards. But, if it is deemed necessary, it can be decided on a release basis that we will postpone the creation of a release branch until an important PR is merged into develop. The PR freeze will remain for non-important PRs, and they can be marked with the donotmerge label as a reminder.","We will then create the release branch with the following branch naming convention release/platform-version; and the PR freeze will be lifted.","Then we will increment the minor version number in the package.json file."]},{"l":"2. Internal testing","p":["Once the release branch has been created, as a team we can all build the release branch locally, and test all the core functionality of the application. Testing of additional functionality will be based, on what features have be added or changed in this version.","This will usually last between half a day and 2 days. Any updates can be opened as PRs directly on the release branch (this is because we don't want to prevent changes to develop affecting the release). When we are happy that the application passes our testings criteria we can move on to the next steps."]},{"i":"3-security-audit-optional","l":"3. Security audit (Optional)","p":["For each release we will decide if and what parts of the application will need to go through the security audit process. This process will be done in parallel to the beta release. If a security audit is deemed necessary, production release will be dependent on the successful completion of said audit."]},{"l":"4. Beta testing","p":["In parallel or in absence of the security audit, we will begin beta testing the next releases. This is will be a public version of the application, that will have the beta release flag enabled."]},{"l":"A. Release","p":["First we create a release, by tagging the latest commit on the release branch and pushing it to the GH repository. The tag should be created with the following naming convention platform-version-beta-build no; so that the correct workflow is used to create the release builds.","Once the tag is pushed, GH should build the application for the correct platform and release channel i.e. release channel being beta in this instance. And then create a draft GH release with the artifacts.","The release manager, can then edit the release in GH with the change log and beta testing instructions. Followed by, publishing the GH release (ensuring the pre-release option is checked) and creating an entry in the GH announcements discussion."]},{"l":"B. Testing","p":["After a beta release has been published, we now need to communicate the release to the public by posting an announcement and changelog in:","Discord #firefly-beta-testing thread","Discord #tech-announcments channel","Beta testing instructions will be referenced in the announcement and these will be defined in the release description. In short, the public will be encouraged to test the application and new features using a developer profile and connected to the respective devnet. The testers can then discuss issues directly in the firefly beta testing thread, or in the release announcement on the GH wiki, before making a bug report in GH if needed."]},{"l":"C. Fixes","p":["If fixes are needed before a release, they can be created as PRs targeting the release branch. If there are fixes that we would like to be retested, we can create a new beta release by going back to step A and incrementing the build number each time."]},{"l":"5. Tag and release","p":["After sufficient beta testing and fixes have been merged into the release branch. We may then release the application as production ready. This involves:","Creating a tag on the latest stable commit in the release branch with the following naming convention platform-version and pushing to the GH repo","The production build automatically starts using GH action when the tag is pushed","Once the production build is finished a draft release is generated in GH","This release can be edited to include the complete, human readable change log","When ready this GH release can be published and an entry to the announcement channel on GH discussions should be generated","The website will automatically pickup the GH release","Once published on GH and the website, we can initiate the action to upload to S3, where the wallet automatically picks up the new release","After the release has been published in three areas, we can swiftly announce the new version in:","slack channel TBD","Discord #firefly-discussion channel","Discord #tech-announcements channel","Optionally, twitter accounts can share this announcement too"]},{"l":"6. Merge release branch into main and develop","p":["After the application has been released we can then merge the release branch into both main and develop branch to ensure they have the latest updates.","Do not use squash and merge at this point as we will loose the commit history used for the changelog","Do not delete the release branch, as it will be used as the base for hotfixes in the future"]},{"l":"Milestone Release Process","p":["The milestone release process is should be followed for large milestones, where we have been using a milestone branch, as opposed to creating PRs directly onto the develop branch.","As a prerequisite to the release process, both the branching strategy and PR management process are to be followed.","For the milestone release process we will aim to follow the below sub processes:"]},{"l":"1. Internal testing","p":["Once the majority of tasks have been completed for a specific milestone, as a team we can all build the milestone branch locally, and test all the core functionality of the application, as well as testing all the additional features and functionality that is included in the milestone.","This will usually last between a day and 1 week. Any updates can be opened as PRs directly on the milestone branch. When we are happy that the application passes our testings criteria we can move on to the next steps."]},{"l":"2. Alpha testing","p":["With the milestone releases, we will utilise a closed testing group so that we can gather wider feedback and testing capabilities before the feature is released to the public. This will be a private build of the application using the alpha release flag."]},{"i":"a-release-1","l":"A. Release","p":["First we create a release, by tagging the latest commit on the milestone branch and pushing it to the GH repository. The tag should be created with the following naming convention platform-version-alpha-build no; so that the correct workflow is used to create the release builds.","Once the tag is pushed, GH should build the application for the correct platform and release channel i.e. release channel being alpha in this instance. And then create a draft GH release with the artifacts.","The release manager, can then edit the release in GH with the change log and beta testing instructions. Followed by, publishing the GH release (ensuring the pre-release option is checked) and creating an entry in the GH announcements discussion."]},{"i":"b-testing-1","l":"B. Testing","p":["After a beta release has been published, we now need to communicate the release to the closed testing group by posting an announcement and changelog in:","Discord #firefly-alpha-testing thread","Alpha testing instructions will be referenced in the announcement and these will be defined in the release description. In short, the closed testing group will be encouraged to test the application and new features using a developer profile and connected to the respective devnet. The testers can then discuss issues directly in the firefly alpha testing thread, or in the release announcement on the GH wiki, before making a bug report in a dedicated online document."]},{"i":"c-fixes-1","l":"C. Fixes","p":["If fixes are needed before a beta release, they can be created as PRs targeting the milestone branch. If there are fixes that we would like to be retested, we can create a new alpha release by going back to step A and incrementing the build number each time."]},{"i":"3-merge-milestone-branch-into-develop--create-release-branch","l":"3. Merge milestone branch into develop & create release branch","p":["After sufficient internal testing and alpha testing, a PR containing the milestone branch can then can then be reviewed on GH and follow the normal PR process; except we should have a minimum of two approvers to merge the milestone into the release branch as it will contain a large amount of changes.","Once the approved and merged is in the develop branch, we can create a release branch following the naming conventions defined in the branching strategy."]},{"i":"4-security-audit-optional","l":"4. Security audit (Optional)","p":["For each release we will decide if and what parts of the application will need to go through the security audit process. This process will be done in parallel to the beta release. If a security audit is deemed necessary, production release will be dependent on the successful completion of said audit."]},{"i":"5-beta-testing-optional","l":"5. Beta testing (Optional)","p":["In parallel or in absence of the security audit, we can begin beta testing the next releases. This is will be a public version of the application, that will have the beta release flag enabled."]},{"i":"a-release-2","l":"A. Release","p":["First we create a release, by tagging the latest commit on the release branch and pushing it to the GH repository. The tag should be created with the following naming convention platform-version-beta-build no; so that the correct workflow is used to create the release builds.","Once the tag is pushed, GH should build the application for the correct platform and release channel i.e. release channel being beta in this instance. And then create a draft GH release with the artifacts.","The release manager, can then edit the release in GH with the change log and beta testing instructions. Followed by, publishing the GH release (ensuring the pre-release option is checked) and creating an entry in the GH announcements discussion."]},{"i":"b-testing-2","l":"B. Testing","p":["After a beta release has been published, we now need to communicate the release to the public by posting an announcement and changelog in:","Discord #firefly-beta-testing thread","Discord #tech-announcments channel","Beta testing instructions will be referenced in the announcement and these will be defined in the release description. In short, the public will be encouraged to test the application and new features using a developer profile and connected to the respective devnet. The testers can then discuss issues directly in the firefly beta testing thread, or in the release announcement on the GH wiki, before making a bug report in GH if needed."]},{"i":"c-fixes-2","l":"C. Fixes","p":["If fixes are needed before a release, they can be created as PRs targeting the release branch. If there are fixes that we would like to be retested, we can create a new beta release by going back to step A and incrementing the build number each time."]},{"l":"6. Tag and release","p":["After sufficient beta testing and fixes have been merged into the release branch. We may then release the application as production ready. This involves:","Creating a tag on the latest stable commit in the release branch with the following naming convention platform-version and pushing to the GH repo","The production build automatically starts using GH action when the tag is pushed","Once the production build is finished a draft release is generated in GH","This release can be edited to include the complete, human readable change log","When ready this GH release can be published and an entry to the announcement channel on GH discussions should be generated","The website will automatically pickup the GH release","Once published on GH and the website, we can initiate the action to upload to S3, where the wallet automatically picks up the new release","After the release has been published in three areas, we can swiftly announce the new version in:","slack channel TBD","Discord #firefly-discussion channel","Discord #tech-announcements channel","Optionally, twitter accounts can share this announcement too"]},{"l":"7. Merge release branch into main and develop","p":["After the milestone has been released we can then merge the release branch into both main and develop branch to ensure they have the latest updates.","Do not use squash and merge at this point as we will loose the commit history used for the changelog","Do not delete the release branch, as it will be used as the base for hotfixes in the future"]},{"l":"Hotfix Release Process","p":["The hotfix release process commences when a maintainer creates a PR with a hotfix targetting a previous release.","A hotfix is any PR that is targeting a previous release directly, and as such should be released after merging into the release branch.","To release a hotfix we will aim to follow the below sub processes."]},{"i":"1-internal-testing-1","l":"1. Internal testing","p":["Once the the PR is deemed ready for a review, as a team we can all build the hotfix branch locally, and test all the core functionality of the application, as well as hotfix functionality.","This will usually last between half a day and 1 full day. Any updates can be committed directly to the hotfix branch. When we are happy that the application passes our testings criteria we can move on to the next steps."]},{"i":"2-pr-approval--merge-into-release-branch","l":"2. PR approval & merge into release branch","p":["After sufficient internal testing, the code can then be reviewed on GH and follow the normal PR process; except we should have a minimum of two approvers to merge the hotfix into the release branch as it is going to be released without additional alpha or beta testings."]},{"l":"3. Tag and release","p":["Once the hotfix has been merged into the release branch; we may then release the application as production ready. This involves:","Creating a tag on the latest stable commit in the release branch with the following naming convention platform-version and pushing to the GH repo","The production build automatically starts using GH action when the tag is pushed","Once the production build is finished a draft release is generated in GH","This release can be edited to include the complete, human readable change log","When ready this GH release can be published and an entry to the announcement channel on GH discussions should be generated","The website will automatically pickup the GH release","Once published on GH and the website, we can initiate the action to upload to S3, where the wallet automatically picks up the new release","After the release has been published in three areas, we can swiftly announce the new version in:","slack channel TBD","Discord #firefly-discussion channel","Discord #tech-announcements channel","Optionally, twitter accounts can share this announcement too"]},{"l":"4. Merge release branch into main and develop","p":["After the hotfix has been released we can then merge the release branch into both main and develop branch to ensure they have the latest updates.","Do not use squash and merge at this point as we will loose the commit history used for the changelog","Do not delete the release branch, as it will be used as the base for hotfixes in the future"]}],[{"l":"Security Incidents","p":["TODO"]},{"l":"Purpose"},{"l":"Scope"},{"l":"Responsibilities"},{"l":"Processes"},{"l":"External Processes"}],[{"l":"Vulnerabilities","p":["TODO"]},{"l":"Purpose"},{"l":"Scope"},{"l":"Responsibilities"},{"l":"Processes"},{"l":"External Processes"}],[{"l":"Glossary"},{"i":"bitcoin-improvement-proposals-bips","l":"\uD83D\uDD87️ Bitcoin Improvement Proposals (BIPs)","p":["Similar to an IOTA TIP (\"Tangle Improvement Proposal\"), a BIP is a proposed plan for improving or adding functionality to a specific part of the protocol. They are important because they define and iterate on mechanisms, rules, and standards for a compatible DLT's (distributed ledger technology) implementation."]},{"i":"bip32---hierarchical-deterministic-hd-wallet","l":"BIP32 - Hierarchical deterministic (HD) wallet","p":["This proposal acts as a definition for how a wallet should derive encryption keys from any given seed. The hierarchy is described by a BIP32 path, which looks like:","NOTE: Sometimes these values are in hexadecimal format (Ledger users will see this when prompted to confirm newly generated addresses).","m- the binary representation of a seed (e.g. 24-word mnemonic)","purpose'*- a fixed value indicating that (usu. 44' representing BIP44) should be used as a standard","coin_type'*- the particular number of a cryptocurrency token (IOTA is 4218'- see SLIP44)","account'*- the index for an account, of which there are 2,147,483,648 possible values (in Firefly these are the individual \"wallets\" in a single profile)","change- 0' or 1' depending on if the address was generated for moving a transaction's remainder funds ( 1) or is an external address for receiving funds ( 0)","address- the index for an address, of which there are 2,147,483,648 possible values (in Firefly these are the individual addresses per each wallet in a single profile)","* The added apostrophe indicates a hardened derivation at that level, which means that it is not possible to link a public key with its parent or child public keys via the public keys alone. With this mechanism being used at at least the account level, the case of an accidental leak of account-specific keys does NOT compromise other accounts or the master (m).","BIP32 is important as without it, you may not necessarily be able to gain access to your funds - you must know which indices the funds reside on to gain access (i.e. you can know which private / public key-pair to generate from the seed). Do not worry though as Firefly sequentially generates new accounts and addresses, which is what allows the balance finder in the settings to more easily find your funds should they be \"lost\"."]},{"i":"bip39---mnemonic-code-key-derivation","l":"BIP39 - Mnemonic code key derivation","p":["This BIP proposes the usage of a generated 12-24 word mnemonic phrase that can be securely converted into a binary seed intended for generating deterministic wallets using BIP32. The major improvement here is that humans can much more easily handle a series of words rather than 0s and 1s, making the storage and recovery of seeds much more friendly.","It consists of two parts: the generation of the mnemonic itself and the conversion into a binary seed. English words are selected from a specially curated list of 2,048 words with an optional passphrase for added security (an empty string is used if empty). The keys are derived through algorithms PBKDF2 and HMAC- SHA512 with a length of 512 bits or 64 bytes."]},{"i":"bip44---multi-account-hierarchy","l":"BIP44 - Multi-account hierarchy","p":["This BIP proposes a definition for the logical hierarchy of deterministic wallets. It allows a user to handle multiple tokens from varying cryptocurrencies with each one having possibilities for millions of accounts each with millions of addresses.","To help understand the technical definition, please read the above description about BIP32 paths. However it's also important to understand how this structure is translated into Firefly:","A profile is at the top-most level of the hierarchy as with Firefly there is one mnemonic per profile","Wallets, also known as \"Accounts\", are three levels lower than the profile / seed (past purpose and coin_type) therefore can only be belonging to a single profile","Addresses are formed on chains from values 0 and 1 on the change level, putting them two levels lower than the account level, however in Firefly we typically only see the receive addresses from the chain when change = 0"]},{"i":"iota-networks","l":"\uD83C\uDF10 IOTA Networks","p":["The IOTA ecosystem contains a variety of networks each with different purposes and use-cases."]},{"l":"Mainnet","p":["The mainnet is the primary network within the IOTA ecosystem where tokens holding real value are transferred to and from participants and data is broadcasted across a public network."]},{"l":"Devnet","p":["The devnet, refers to the secondary network within the IOTA ecosystem where tokens of fake value are transacted with, and data is broadcasted publicly across the network."]},{"l":"Testnet","p":["Similar to the devnet, the testnet is a network that until recently was the secondary network for the Chrysalis upgrade. The network still exists and is still being used for testing transactions and data message broadcasting."]},{"l":"Private Tangles","p":["Private tangles are networks that can be setup for use by an individual or even a smart city. The tokens do NOT hold real-world value, and the data messages are broadcasted onto the configured private network."]},{"i":"stronghold","l":"\uD83D\uDD10 Stronghold","p":["Stronghold is an open-source software library developed and maintained by the IOTA Foundation (see stronghold.rs). It deals with the protection of important secrets like the seed of a Firefly profile or the public-private key pairs for accounts (or wallets) within a Firefly profile.","It is designed to be used within other libraries, such as wallet.rs, or even within the provided peer-to-peer (p2p) communication layer for when higher security is needed."]}]]